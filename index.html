<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我们的时光展览馆 | 周浩 & 物理超度</title>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 Google Fonts (手写体) -->
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@300;700&family=Inter:wght@400;600&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="assets/css/base.css">
    <link rel="stylesheet" href="assets/css/layout.css">
    <link rel="stylesheet" href="assets/css/components.css">
    <link rel="stylesheet" href="assets/css/sections.css">
    <link rel="stylesheet" href="assets/css/mobile.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <!-- 背景音乐 -->
    <audio id="bgm" src="love-song.mp3" loop preload="auto"></audio>

    <!-- 粒子背景 -->
    <div id="canvas-container"></div>

    <!-- 音乐播放器 -->
    <div class="music-player">
        <div class="music-info">
            <div class="music-title">Love song</div>
            <div class="music-artist">Lana Del Rey</div>
        </div>
        <div class="vinyl"></div>
        <button id="music-toggle" class="music-toggle" aria-label="播放/暂停音乐">▶︎</button>
    </div>

    <!-- 导航 -->
    <nav>
        <div class="logo">2023-2025 RELATIONSHIP</div>
        <div class="nav-links">
            <a href="#personas">Persona</a>
            <a href="#earth-section">Distance</a>
            <a href="#timeline">Timeline</a>
            <a href="#advice">Growth</a>
        </div>
    </nav>

    <!-- 1. 序厅 -->
    <section id="hero">
        <h1 class="hero-title">我们的爱与成长</h1>
        <p class="hero-desc">
            这是一份关于“看见”的报告。<br>
            看见彼此的付出，看见差异背后的互补，看见我们共同走过的路。
        </p>
        <div class="scroll-down">↓</div>
    </section>

    <!-- 2. 双星画像 -->
    <section id="personas">
        <div class="section-header">
            <div class="section-subtitle">THE PERSONA</div>
            <h2 class="section-title">在爱里，我们是谁</h2>
        </div>

        <div class="persona-container">
            <!-- 大思 -->
            <div class="tilt-card girl-theme" data-tilt>
                <div class="card-inner">
                    <div class="avatar">🌸</div>
                    <h3>物理超度 (大思)</h3>
                    <div class="tags">
                        <span>生活的导演</span>
                        <span>热情的分享者</span>
                        <span>坚定的梦想家</span>
                    </div>
                    <p style="margin-top:20px; line-height:1.6; font-size:0.9rem; color:#ccc;">
                        <strong>1. 充满生命力的引领者：</strong><br>
                        你就像这段关系里的小太阳，总是充满活力和新奇的想法。无论是策划旅行、寻找美食，还是规划未来的留学蓝图，你都展现出了非凡的行动力和对生活的热爱。你不仅把自己的生活过得丰富多彩，也渴望带着周浩一起看更大的世界。<br><br>
                        <strong>2. 勇敢的爱人：</strong><br>
                        面对异地的挑战，你没有退缩，而是用无数的分享、照片和视频填满了距离。你的“焦虑”其实是因为太在意，太想把这段关系经营好。
                    </p>
                    <div class="highlight-text">
                        <strong>✨ 闪光点：</strong><br>
                        你的独立和坚韧（一个人在国外生活、处理各种琐事）非常迷人，这让周浩感到既佩服又安心。
                    </div>
                </div>
            </div>

            <!-- 周浩 -->
            <div class="tilt-card boy-theme" data-tilt>
                <div class="card-inner">
                    <div class="avatar">🌲</div>
                    <h3>周浩 (PongKa)</h3>
                    <div class="tags">
                        <span>稳健的守护者</span>
                        <span>温和的倾听者</span>
                        <span>潜在的实干家</span>
                    </div>
                    <p style="margin-top:20px; line-height:1.6; font-size:0.9rem; color:#ccc;">
                        <strong>1. 安静而坚定的陪伴：</strong><br>
                        你可能不善言辞，但你的爱藏在细节里。接送大思、陪她吃想吃的东西、在她情绪崩溃时做那个稳定的容器。你就像一棵树，虽然不会每天把爱挂在嘴边，但始终站在那里，给她依靠。<br><br>
                        <strong>2. 包容与适应：</strong><br>
                        你有着极强的包容性，愿意去适应大思的节奏，去尝试新的事物。你的“随和”其实是一种温柔的让步，是为了让两个人相处得更舒服。
                    </p>
                    <div class="highlight-text">
                        <strong>🌱 成长点：</strong><br>
                        邮件中你坦诚地面对了自己的“逃避”，这种自我觉察非常珍贵。这说明你已经准备好为了这段关系去承担更多责任。
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- 3. 爱的语言漂浮画布 -->
    <section id="love-float-section">
        <div class="love-float">
            <div class="love-float-heading">
                <div class="section-subtitle">UNDERSTANDING</div>
                <h2 class="section-title">要如何翻译我爱你</h2>
            </div>
            <div id="love-float-canvas" class="love-float-canvas"></div>
            <div class="love-float-overlay">SWIPE LEFT TO SPEED · SWIPE RIGHT TO SLOW</div>
        </div>
    </section>

    <!-- 4. 爱的默契 (Galaxy Lenses) -->
    <section id="interaction" class="lens-section">
        <div class="lens-loading" id="lens-loading">正在连接星域...</div>
        <div class="lens-canvas" id="lens-canvas"></div>
        <div class="lens-ui" id="lens-ui">
            <h2>GALAXY LENSES</h2>
            <div class="lens-hint">🖱️ 双击屏幕散开 · 拖拽透镜翻转 · 拖拽背景旋转</div>
        </div>
    </section>

    <!-- 5. 3D地球 (Distance) -->
    <section id="earth-section">
        <div id="earth-container"></div>
        <div class="earth-overlay">
            <div class="section-header visible">
                <div class="section-subtitle">GLOBAL CONNECTION</div>
                <h2 class="section-title">跨越山海的爱</h2>
                <p style="margin-top:20px; color:#aaa;">从武汉到加州，再到未来的欧洲。<br>距离拉长了思念，却从未剪断连接。</p>
            </div>
        </div>
    </section>

    <!-- 5. Timeline (Horizontal Scroll) -->
    <section id="timeline">
        <div class="section-header">
            <div class="section-subtitle">MEMORY LANE</div>
            <h2 class="section-title">那些闪光的日子</h2>
        </div>

        <div class="timeline-wrapper" id="scrollContainer">
            <div class="timeline-track">
                <!-- 2023.12 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2023.12</span>
                        <h3>初识的烟火气：螺蛳粉与六级考试</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            武汉的冬天，期末周的缝隙里找美食，从螺蛳粉到热干面；六级和实验报告的压力，被互相吐槽和陪伴融化。
                        </p>
                        <div class="chat-quote">"本来还想等你开完会去找你 现在一点也不想 你赶紧开完会回去洗澡去"</div>
                        <div class="chat-quote">"不懂螺蛳粉的人 亏大了"</div>
                    </div>
                </div>

                <!-- 2024.01 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.01</span>
                        <h3>寒假暂别：云端的想念</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            放假回家进入异地。各自家乡的日常、饭菜、亲戚八卦都要分享，见不到面但分享欲不减。
                        </p>
                        <div class="chat-quote">"我妈说每天都要敷面膜和突身体乳"</div>
                        <div class="chat-quote">"梦到你了...梦到在梦里吃了一晚上饭"</div>
                    </div>
                </div>

                <!-- 2024.02 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.02</span>
                        <h3>重逢与情人节：迟到的庆祝</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            返校结束异地，虽然过年和情人节不在一起，但约定回校后补庆祝，一起吃好吃的。
                        </p>
                        <div class="chat-quote">"情人节快乐呀宝"</div>
                        <div class="chat-quote">"给你的礼物直接等你过来"</div>
                    </div>
                </div>

                <!-- 2024.03 - 2024.06 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.03 - 2024.06</span>
                        <h3>并肩作战：备考与规划</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            一起为“出去看看”备考雅思托福，往返图书馆和实验室。焦虑与疲惫并存，但目标一致。
                        </p>
                        <div class="chat-quote">"我们一起看电影吃墨西哥牛油果酱"</div>
                        <div class="chat-quote">"虽然现在相隔千里但每一次问候每一次笑声都让我觉得你就在身边" (回忆)</div>
                    </div>
                </div>

                <!-- 2024.07 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.07</span>
                        <h3>跨越太平洋：大思赴美</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            大思去美国暑期项目。时差是第一个障碍；视频通话成了最期待的时刻。
                        </p>
                        <div class="chat-quote">"我从美国回来 我们刚好 300天"</div>
                        <div class="chat-quote">"这里随便拉一个人的出生配置对我来说都是顶配了"</div>
                    </div>
                </div>

                <!-- 2024.08 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.08</span>
                        <h3>加州阳光：分享与憧憬</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            大思分享加州的阳光、海滩与物价，周浩在国内实习；一起讨论未来可能的共同旅行。
                        </p>
                        <div class="chat-quote">"天天住在这里有什么烦恼 真是做梦都要笑醒"</div>
                        <div class="chat-quote">"想和你一起看电影吃墨西哥牛油果酱"</div>
                    </div>
                </div>

                <!-- 2024.09 - 2024.12 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2024.09 - 2024.12</span>
                        <h3>大四时光：最后的校园倒计时</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            大思回国，更加珍惜校园日子：上课、食堂、吐槽奇葩课程，平淡却珍贵。
                        </p>
                        <div class="chat-quote">"一觉醒来怎么下雨了"</div>
                        <div class="chat-quote">"我们俩的大学比别人长一点"</div>
                    </div>
                </div>

                <!-- 2025.01 - 2025.04 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2025.01 - 2025.04</span>
                        <h3>最后的冲刺：论文与申请</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            毕设与留学申请白热化，互相改文书、写代码、查重，在压力下坚持。
                        </p>
                        <div class="chat-quote">"写文书是世界上最恶心的事情"</div>
                        <div class="chat-quote">"写不完了 毕设"</div>
                    </div>
                </div>

                <!-- 2025.05 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2025.05</span>
                        <h3>520与毕业季：离别的序曲</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            拍毕业照、吃散伙饭，在校园各处留影。临近各奔东西，关系更紧。
                        </p>
                        <div class="chat-quote">"我们是恋爱天才"</div>
                        <div class="chat-quote">"以后有这种活动你可以多多参加...多认识点人扯皮都方便"</div>
                    </div>
                </div>

                <!-- 2025.06 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2025.06</span>
                        <h3>盛夏的告别：各奔东西</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            正式毕业，一起徒步看日出；武汉站的分别是不舍，也是为了更好的未来。
                        </p>
                        <div class="chat-quote">"不要忘记这个我在的城市"</div>
                        <div class="chat-quote">"以后有机会一定要一起去一次"</div>
                    </div>
                </div>

                <!-- 2025.07 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2025.07</span>
                        <h3>转折点：一封长信</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            Gap Year 尘埃落定。周浩写下长信，坦诚逃避与爱意，这是关系成熟的关键时刻。
                        </p>
                        <div class="chat-quote">"说是懒惰其实是逃避...我无法完全而又真诚的接受你对我的爱，这让我相形见绌，但我又无法承认我不爱你。" —— 2025.07.23 邮件</div>
                    </div>
                </div>

                <!-- 2025.08 - 2025.10 -->
                <div class="time-event">
                    <div class="event-card">
                        <span class="event-date">2025.08 - 2025.10</span>
                        <h3>各自努力：为了重逢</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            大思在法国适应新生活，周浩在国内工作与申请。时差与距离里，各自努力等待再见。
                        </p>
                        <div class="chat-quote">"我每天要有好多好多个瞬间都觉得 这种好日子 应该我们一起享受"</div>
                    </div>
                </div>

                <!-- 2025.11 -->
                <div class="time-event">
                    <div class="event-card" style="border-color: #ffd700;">
                        <span class="event-date" style="color:#ffd700;">2025.11</span>
                        <h3>两周年：爱是共同书写的诗篇</h3>
                        <p style="font-size:0.9rem; color:#ccc; margin-top:10px;">
                            两年从武汉到世界，虽相隔千里，心更近。未来很长，要一起走下去。
                        </p>
                        <div class="chat-quote">"愿未来的每一个七百天，我们都能继续并肩走下去...我在这端，把日子过成能见到你的那条路" —— 2025.11.20 邮件</div>
                    </div>
                </div>
                
                <!-- Spacer -->
                <div style="width: 50px;"></div>
            </div>
        </div>
    </section>

    <!-- 6. Advice (Blur Reveal) -->
    <section id="advice">
        <div class="section-header">
            <div class="section-subtitle">GROWTH</div>
            <h2 class="section-title">成长契约</h2>
        </div>

        <div class="advice-box">
            <div class="advice-col">
                <h3>给周浩：从“陪伴”到“并肩”</h3>

                <div class="advice-item">
                    <div class="advice-title">1. 主动一点点，惊喜多一点</div>
                    <div class="advice-deep">
                        大思其实特别好哄，她需要的不是你做多惊天动地的大事，而是看到你把她的事放在心上。当她感受到你的主动时，她的焦虑就会自动消散。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>下次不用等大思问，主动发一句：“今天我查了一下那个学校的官网，发现……” 或者 “我看到一个好吃的，下次带你去。” 这种主动会让大思觉得你在和她一起努力。</span>
                    </div>
                </div>

                <div class="advice-item">
                    <div class="advice-title">2. 表达你的感受，不仅仅是听</div>
                    <div class="advice-deep">
                        你不说，大思会以为你不在乎，或者你正在冷暴力。其实你有压力、有迷茫、甚至是不开心都可以告诉她。示弱不是软弱，而是信任。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>当你感到累或不知道说什么时，试着说：“其实我也很担心申请不顺利，但我会努力的，我们一起加油。” 甚至可以直接说“我今天状态不好，求抱抱”。</span>
                    </div>
                </div>

                <div class="advice-item">
                    <div class="advice-title">3. 用行动兑现承诺</div>
                    <div class="advice-deep">
                        Gap Year 已经过去了，现在最重要的是抓住当下的机会。不需要画大饼，只需要一个个小小的勾选框被填满。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>制定一个可视化的进度表（哪怕只是备忘录截图），按时完成申请的小目标。这就是给大思最好的定心丸。</span>
                    </div>
                </div>

                <div class="advice-item">
                    <div class="advice-title">4. 学会“有效”的争吵</div>
                    <div class="advice-deep">
                        当冲突发生时，逃避和睡觉并不能解决问题，只会让大思觉得被抛弃。她需要的是被“接住”，而不是被冷落。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>如果真的很累，可以请求暂停：“我现在脑子有点乱，给我半小时冷静一下，回来我们好好聊，好吗？” 关键是承诺“会回来”。</span>
                    </div>
                </div>
            </div>

            <div class="advice-col">
                <h3>给大思：从“焦急”到“信任”</h3>

                <div class="advice-item">
                    <div class="advice-title">1. 给他一点成长的空间</div>
                    <div class="advice-deep">
                        周浩已经意识到了自己的问题，正在努力改变（比如那封邮件）。改变需要时间，有时候，稍微慢一点，多一点鼓励，他会走得更稳。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>当他做了一件小事（比如主动报备），用力夸他。正向反馈永远比催促更有效。</span>
                    </div>
                </div>

                <div class="advice-item">
                    <div class="advice-title">2. 享受当下，不只看未来</div>
                    <div class="advice-deep">
                        虽然未来很重要，但也不要忽略了当下的快乐。如果每次聊天都是“任务清单”和“进度检查”，爱意会被耗损。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>偶尔放下“任务清单”，单纯地享受一次视频通话，聊聊八卦，看看对方的脸，只谈风月，不谈前途。也很美好。</span>
                    </div>
                </div>

                <div class="advice-item">
                    <div class="advice-title">3. 做回那个自信的 ENTP</div>
                    <div class="advice-deep">
                        你是发光的小太阳，不要让异地的焦虑掩盖了你的光芒。你的生活不仅有等待，还有自己在法国的精彩。你过得越好，对他越有吸引力。
                    </div>
                    <div class="advice-action">
                        <span>💡 试一试：</span>
                        <span>哪怕周浩没有回消息，也要开心地去探索一个新的街区，拍一张好看的照片发朋友圈。你的快乐是自给自足的。</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- 7. Footer -->
    <section id="footer">
        <div class="footer-inner">
            <div class="final-quote">
                "无论身在何处，<br>我们的引力始终指向彼此"
            </div>
            <p class="footer-desc">
                愿你们在彼此的爱意中，成为更好的自己，也成就更好的我们。
            </p>
            <div class="footer-meta">
                2025 Relationship Exhibition | Created for Zhou Hao & Wuli Chaodu
            </div>
        </div>
    </section>

    <script>
        // --- 1. Canvas Particle Background ---
        const canvas = document.createElement('canvas');
        document.getElementById('canvas-container').appendChild(canvas);
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let particles = [];
        let meteors = [];
        
        function initParticles() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            const count = 240;
            particles = new Array(count).fill(0).map(() => ({
                x: Math.random() * width,
                y: Math.random() * height,
                r: Math.random() * 2.2 + 0.3,
                d: Math.random() * 20,
                drift: (Math.random() - 0.5) * 0.15
            }));
            meteors = [];
        }

        function drawParticles() {
            ctx.clearRect(0,0,width,height);
            // Meteors
            ctx.save();
            ctx.lineCap = 'round';
            meteors.forEach(m => {
                ctx.strokeStyle = `rgba(255,255,255,${m.alpha})`;
                ctx.lineWidth = m.thickness;
                ctx.beginPath();
                ctx.moveTo(m.x, m.y);
                ctx.lineTo(m.x - m.dx * m.length, m.y - m.dy * m.length);
                ctx.stroke();
            });
            ctx.restore();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            particles.forEach(p => {
                ctx.moveTo(p.x, p.y);
                ctx.arc(p.x, p.y, p.r, 0, Math.PI*2, true);
            });
            ctx.fill();
            moveParticles();
            moveMeteors();
        }

        function moveParticles() {
            particles.forEach(p => {
                p.y -= 0.35; // Move up a bit faster
                p.x += p.drift;
                if(p.y < -10) p.y = height + 10;
                if(p.x < -10) p.x = width + 10;
                if(p.x > width + 10) p.x = -10;
            });
        }

        function spawnMeteor() {
            // 让流星起点与方向更随机：水平位置可超出屏幕，方向左右均可
            const startX = Math.random() * (width + 160) - 80; // -80 ~ width+80
            const startY = -40 + Math.random() * 30;           // 轻微抖动的起点高度
            const angle = Math.random() * 0.6 + 0.25;         // 约 14°~49°
            const dir = Math.random() < 0.5 ? -1 : 1;         // 左/右方向
            const speed = Math.random() * 4 + 6;              // 6~10
            const dx = Math.cos(angle) * dir;
            const dy = Math.sin(angle);                       // 始终向下
            meteors.push({
                x: startX,
                y: startY,
                dx,
                dy,
                speed,
                length: Math.random() * 70 + 70,
                thickness: Math.random() * 1 + 1,
                alpha: 0.9
            });
        }

        function moveMeteors() {
            meteors.forEach(m => {
                m.x += m.dx * m.speed;
                m.y += m.dy * m.speed;
                m.alpha -= 0.01;
            });
            meteors = meteors.filter(m => m.x < width + 200 && m.y < height + 200 && m.alpha > 0.05);
        }

        setInterval(spawnMeteor, 3000);

        setInterval(drawParticles, 30);
        window.addEventListener('resize', initParticles);
        initParticles();


        // --- 2. Three.js Earth (interactive with city markers) ---
        const earthContainer = document.getElementById('earth-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(devicePixelRatio);
        earthContainer.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.55));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.75);
        dirLight.position.set(5, 3, 5);
        scene.add(dirLight);

        const globeGroup = new THREE.Group();
        scene.add(globeGroup);

        const loader = new THREE.TextureLoader();
        const earthTex = loader.load('https://threejs.org/examples/textures/land_ocean_ice_cloud_2048.jpg');
        const earthGeom = new THREE.SphereGeometry(3, 64, 64);
        const earthMat = new THREE.MeshPhongMaterial({
            map: earthTex,
            specular: 0x222222,
            shininess: 8
        });
        const earthMesh = new THREE.Mesh(earthGeom, earthMat);
        globeGroup.add(earthMesh);

        // Glow atmosphere
        const atmosphereGeom = new THREE.SphereGeometry(3.05, 64, 64);
        const atmosphereMat = new THREE.MeshBasicMaterial({
            color: 0x6ea8ff,
            transparent: true,
            opacity: 0.1,
            side: THREE.BackSide
        });
        const atmosphereMesh = new THREE.Mesh(atmosphereGeom, atmosphereMat);
        globeGroup.add(atmosphereMesh);

        // Starfield background
        const starsGeom = new THREE.BufferGeometry();
        const starCount = 800;
        const starPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = 60 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i*3+1] = r * Math.cos(phi);
            starPos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
        }
        starsGeom.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.7 });
        const stars = new THREE.Points(starsGeom, starsMat);
        scene.add(stars);

        // City markers
        const cities = [
            { name: '武汉', en: 'Wuhan', lat: 30.5928, lon: 114.3055 },
            { name: '洛杉矶', en: 'Los Angeles', lat: 34.0522, lon: -118.2437 },
            { name: '尼斯', en: 'Nice', lat: 43.7102, lon: 7.2620 },
            { name: '都柏林', en: 'Dublin', lat: 53.3498, lon: -6.2603 },
        ];

        const markerGroup = new THREE.Group();
        globeGroup.add(markerGroup);

        const markerGeom = new THREE.SphereGeometry(0.08, 16, 16);
        const markerMat = new THREE.MeshPhongMaterial({
            color: 0xf5d06f,
            emissive: 0x6b4b1a,
            emissiveIntensity: 0.45,
            shininess: 40
        });

        function latLonToVector3(lat, lon, radius) {
            const phi = THREE.MathUtils.degToRad(90 - lat);
            const theta = THREE.MathUtils.degToRad(lon + 180);
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }

        function makeLabelTexture(text) {
            const c = document.createElement('canvas');
            c.width = 256; c.height = 64;
            const ctx = c.getContext('2d');
            ctx.clearRect(0,0,c.width,c.height);
            // background with subtle glass effect
            const grad = ctx.createLinearGradient(0,0,c.width,0);
            grad.addColorStop(0,'rgba(20,24,35,0.65)');
            grad.addColorStop(1,'rgba(40,45,65,0.65)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,c.width,c.height);
            ctx.strokeStyle = 'rgba(255,255,255,0.18)';
            ctx.strokeRect(1.5,1.5,c.width-3,c.height-3);
            ctx.fillStyle = '#f8fbff';
            ctx.font = 'bold 26px "Playfair Display", "Inter", sans-serif';
            ctx.textBaseline = 'middle';
            ctx.textAlign = 'center';
            ctx.fillText(text, c.width/2, c.height/2);
            const tex = new THREE.CanvasTexture(c);
            tex.needsUpdate = true;
            return tex;
        }

        cities.forEach(city => {
            const pos = latLonToVector3(city.lat, city.lon, 3.02);
            const m = new THREE.Mesh(markerGeom, markerMat.clone());
            m.position.copy(pos);
            markerGroup.add(m);

            // Label
            const labelMat = new THREE.SpriteMaterial({
                map: makeLabelTexture(`${city.en}`),
                transparent: true,
                depthWrite: false
            });
            const label = new THREE.Sprite(labelMat);
            label.scale.set(2.0, 0.48, 1);
            const labelPos = pos.clone().normalize().multiplyScalar(3.25);
            label.position.copy(labelPos);
            markerGroup.add(label);
        });

        camera.position.set(0, 0, 9);

        let isDragging = false;
        let prev = { x: 0, y: 0 };
        let rotation = { x: 0, y: 0 };

        earthContainer.addEventListener('pointerdown', (e) => {
            isDragging = true;
            prev.x = e.clientX;
            prev.y = e.clientY;
        });
        window.addEventListener('pointerup', () => { isDragging = false; });
        window.addEventListener('pointermove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - prev.x;
            const dy = e.clientY - prev.y;
            prev.x = e.clientX;
            prev.y = e.clientY;
            rotation.y += dx * 0.005;
            rotation.x += dy * 0.005;
            rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, rotation.x));
        });

        function animateEarth() {
            requestAnimationFrame(animateEarth);
            if (!isDragging) {
                rotation.y += 0.0008;
            }
            globeGroup.rotation.set(rotation.x, rotation.y, 0);
            renderer.render(scene, camera);
        }
        animateEarth();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 2.1 Galaxy Lenses (Interaction replacement) ---
        (() => {
            const container = document.getElementById('lens-canvas');
            const loading = document.getElementById('lens-loading');
            const uiLayer = document.getElementById('lens-ui');
            if (!container || !window.THREE || !window.gsap) return;

            const cardsData = [
                { title: "大思的语言", front: "快去申请学校，怎么还没做这个？", back: "我想和你有一个确定的未来，我想和你一起变得更好。" },
                { title: "周浩的语言", front: "睡一觉就好了，没事的。", back: "我不想让你这么累，无论发生什么，我都在这里陪着你。" },
                { title: "我们的模式", front: "风筝 & 线", back: "大思带着周浩看到更广阔的世界，周浩给大思疲惫时停靠的港湾。" },
                { title: "关于“吃”", front: "饿死我了 / 吃个饭去 / 给你带了呀米呀米", back: "你是我的生活必需品。我想见你，哪怕只是坐在一起吃顿无聊的饭。" },
                { title: "周浩的“随便”", front: "都行 / 听你的 / 随便 / 没意见", back: "因为是你，所以我都喜欢。我信任你的品味，也享受被你安排的安稳感。" },
                { title: "大思的“分享”", front: "[图片] (路边的狗) / [图片] (奇怪的云)", back: "我的世界如果缺少了你的注视，就变得黯淡无光。我想让你参与我生命的每一分钟。" },
                { title: "争吵时的“晚安”", front: "睡觉吧 / 困了 / 晚安 (在气氛不对时)", back: "我不想吵架伤感情。我们暂停一下，但请放心，明天醒来我依然爱你。" },
                { title: "周浩的“在楼下”", front: "下来 / 到楼下了 / 给你放门口了", back: "我不善言辞，但我永远是你触手可及的依靠。你需要我的时候，我一定在。" },
                { title: "大思的“骂人”", front: "你是猪吗 / 傻瓜 / 欠揍", back: "这是我对最亲密的人才有的撒娇。你在我面前可以不用伪装成大人。" },
                { title: "周浩的“定心丸”", front: "小问题 / 没事 / 不急 / 慢慢来", back: "别慌，天塌下来有我顶着。无论遇到什么麻烦，我都会陪你一起解决，做你最稳的后盾。" },
                { title: "大思的“蓝图”", front: "以后我们去... / 以后养只狗", back: "我的未来规划里，每一帧都有你的身影。等待不是因为无奈，而是因为对我们共同生活的笃定。" },
                { title: "最高级的“不嫌弃”", front: "拉屎去了 / 闻屁 / [丑照]", back: "我们在彼此面前不需要任何伪装。爱就是见过你最真实、最狼狈的样子，依然觉得你可爱。" },
                { title: "角色扮演", front: "兄弟 / 老弟 / 姐 / 义父", back: "我们不仅是情侣，更是死党和战友。这种多重羁绊是谁也剪不断的。" },
                { title: "异地的“通感”", front: "我也在吃 / 梦到你了 / [同时发消息]", back: "虽然身处异地，但灵魂在同一时区。我在努力用细节填补物理距离。" },
                { title: "强制休息", front: "快去睡 / 别学了 / 挂了昂", back: "看着你累我会心疼。比起你的前途，我更在意你的健康。" }
            ];

            const size = () => ({
                w: Math.max(container.clientWidth || container.offsetWidth || window.innerWidth, 1),
                h: Math.max(container.clientHeight || container.offsetHeight || window.innerHeight, 1)
            });

            const { w: initW, h: initH } = size();
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x020205, 0.015);

            const lensCamera = new THREE.PerspectiveCamera(45, initW / initH, 0.1, 1000);
            lensCamera.position.z = 45;

            const lensRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            lensRenderer.setSize(initW, initH);
            lensRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            lensRenderer.physicallyCorrectLights = true;
            lensRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            lensRenderer.outputEncoding = THREE.sRGBEncoding;
            container.appendChild(lensRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xffd700, 2.5, 100);
            pointLight1.position.set(15, 15, 20);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xaaccff, 2.5, 100);
            pointLight2.position.set(-15, -15, 20);
            scene.add(pointLight2);

            const rectLight = new THREE.RectAreaLight(0xffffff, 5, 20, 20);
            rectLight.position.set(0, 20, 0);
            rectLight.lookAt(0, 0, 0);
            scene.add(rectLight);

            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 4000;
            const posArray = new Float32Array(starsCount * 3);
            for (let i = 0; i < starsCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 300;
            }
            starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starsMat = new THREE.PointsMaterial({ size: 0.15, color: 0xffffff, transparent: true, opacity: 0.6 });
            const starField = new THREE.Points(starsGeo, starsMat);
            scene.add(starField);

            const lenses = [];
            const tiltGroup = new THREE.Group();
            scene.add(tiltGroup);
            const lensGroup = new THREE.Group();
            tiltGroup.add(lensGroup);
            tiltGroup.rotation.z = Math.PI / 4;
            tiltGroup.rotation.x = Math.PI / 2.5;

            function createTextTexture(text, title = '', options = {}) {
                const { isBack = false, showTitle = true } = options;
                const c = document.createElement('canvas');
                c.width = 512;
                c.height = 512;
                const ctx = c.getContext('2d');

                // Glass body (更实心、不透明)
                ctx.beginPath();
                ctx.arc(256, 256, 230, 0, Math.PI * 2);
                ctx.fillStyle = isBack ? '#121a2c' : 'rgba(42, 48, 62, 0.98)';
                ctx.fill();

                // Edge halo (纯白不透明)
                const edge = ctx.createRadialGradient(256, 256, 180, 256, 256, 230);
                edge.addColorStop(0, 'rgba(255,255,255,0)');
                edge.addColorStop(1, 'rgba(235, 239, 255, 1)');
                ctx.fillStyle = edge;
                ctx.fill();

                // Rim stroke
                ctx.lineWidth = 6;
                ctx.strokeStyle = 'rgba(236, 242, 255, 0.9)';
                ctx.stroke();

                // Specular arc (简洁高光)
                const highlight = ctx.createLinearGradient(180, 140, 340, 220);
                highlight.addColorStop(0, 'rgba(255,255,255,0)');
                highlight.addColorStop(0.45, 'rgba(255,255,255,0.35)');
                highlight.addColorStop(0.7, 'rgba(255,255,255,0.05)');
                highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight;
                ctx.beginPath();
                ctx.ellipse(250, 190, 140, 50, -0.35, 0, Math.PI * 2);
                ctx.fill();

                // Additional spec line
                ctx.fillStyle = 'rgba(255,255,255,0.18)';
                ctx.beginPath();
                ctx.ellipse(300, 220, 100, 18, -0.3, 0, Math.PI * 2);
                ctx.fill();

                ctx.textAlign = 'center';
                ctx.fillStyle = '#fefefe';
                ctx.shadowColor = 'rgba(0,0,0,0.25)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 2;

                if (showTitle && title) {
                    ctx.font = 'bold 30px "Playfair Display", "Noto Serif SC", serif';
                    ctx.fillText(title, 256, 120);
                }

                ctx.font = isBack ? '32px "Noto Serif SC", serif' : '30px "Courier Prime", monospace';
                let line = '';
                let y = showTitle && title ? 170 : 150;
                const lineHeight = 42;
                const maxWidth = 360;
                for (let n = 0; n < text.length; n++) {
                    const testLine = line + text[n];
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, 256, y);
                        line = text[n];
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, 256, y);

                const texture = new THREE.CanvasTexture(c);
                texture.anisotropy = lensRenderer.capabilities.getMaxAnisotropy();
                return texture;
            }

            const lensGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.15, 64);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.05,
                roughness: 0.02,
                transmission: 0.98,
                thickness: 2.5,
                envMapIntensity: 1.5,
                clearcoat: 1.0,
                clearcoatRoughness: 0.0,
                ior: 1.7,
                side: THREE.DoubleSide
            });

            function getFibonacciSpherePoints(samples, radius) {
                const points = [];
                const phi = Math.PI * (3.0 - Math.sqrt(5.0));
                for (let i = 0; i < samples; i++) {
                    const y = 1 - (i / (samples - 1)) * 2;
                    const radiusAtY = Math.sqrt(1 - y * y);
                    const theta = phi * i;
                    const x = Math.cos(theta) * radiusAtY;
                    const z = Math.sin(theta) * radiusAtY;
                    points.push(new THREE.Vector3(x * radius, y * radius, z * radius));
                }
                return points;
            }

            const targetPoints = getFibonacciSpherePoints(cardsData.length, 11.5);

            cardsData.forEach((data, i) => {
                const lens = new THREE.Mesh(lensGeo, glassMat.clone());
                const frontTex = createTextTexture(data.front, data.title, { isBack: false, showTitle: true });
                const planeGeo = new THREE.PlaneGeometry(3.6, 3.6);
                const frontMesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: frontTex, transparent: true, side: THREE.FrontSide }));
                frontMesh.rotation.x = -Math.PI / 2;
                frontMesh.position.y = 0.081;
                frontMesh.scale.set(0.85, 0.85, 0.85);
                lens.add(frontMesh);

                const backTex = createTextTexture(data.back, '', { isBack: true, showTitle: false });
                const backMesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: backTex, transparent: true, side: THREE.FrontSide }));
                backMesh.rotation.x = Math.PI / 2;
                backMesh.rotation.z = Math.PI;
                backMesh.position.y = -0.081;
                backMesh.scale.set(0.85, 0.85, 0.85);
                lens.add(backMesh);

                const ringRadius = 12;
                const angleStep = (Math.PI * 2) / cardsData.length;
                const currentAngle = i * angleStep;
                const initX = Math.cos(currentAngle) * ringRadius;
                const initY = 0;
                const initZ = Math.sin(currentAngle) * ringRadius;
                lens.position.set(initX, initY, initZ);
                lens.rotation.set(0, -currentAngle, 0);
                lens.rotateX(Math.PI / 2);
                lens.rotateX(-Math.PI / 6);

                const targetPos = targetPoints[i];
                const targetRot = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0);

                lens.userData = {
                    id: i,
                    targetPos,
                    targetRot,
                    basePos: lens.position.clone(),
                    velocity: new THREE.Vector3(),
                    floatPhase: Math.random() * Math.PI * 2
                };

                lensGroup.add(lens);
                lenses.push(lens);
            });

            if (loading) loading.style.opacity = 0;

            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let isScattered = false;
            let activeLens = null;
            let isDragging = false;
            let prevMousePos = { x: 0, y: 0 };
            let sceneRotationVelocityX = 0;
            let sceneRotationVelocityY = 0;

            const updateMouse = (e) => {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            };

            const scatterLenses = () => {
                gsap.to(tiltGroup.rotation, { x: 0, z: 0, duration: 3, ease: "power2.inOut" });
                lenses.forEach((lens, index) => {
                    gsap.to(lens.position, {
                        x: lens.userData.targetPos.x,
                        y: lens.userData.targetPos.y,
                        z: lens.userData.targetPos.z,
                        duration: 2.5,
                        ease: "power3.out",
                        delay: index * 0.05
                    });
                    gsap.to(lens.rotation, {
                        x: lens.userData.targetRot.x,
                        y: lens.userData.targetRot.y,
                        z: lens.userData.targetRot.z,
                        duration: 3,
                        ease: "power2.out"
                    });
                });
                gsap.to(lensCamera.position, { z: 40, duration: 3, ease: "power2.inOut" });
                if (uiLayer) {
                    uiLayer.style.opacity = 0;
                    setTimeout(() => { uiLayer.style.pointerEvents = 'none'; }, 500);
                }
            };

            container.addEventListener('dblclick', () => {
                if (!isScattered) {
                    isScattered = true;
                    scatterLenses();
                }
            });

            const onMouseDown = (e) => {
                if (!isScattered) return;
                updateMouse(e);
                raycaster.setFromCamera(mouse, lensCamera);
                const intersects = raycaster.intersectObjects(lenses);

                isDragging = true;
                prevMousePos = { x: e.clientX, y: e.clientY };

                if (intersects.length > 0) {
                    activeLens = intersects[0].object;
                    gsap.killTweensOf(activeLens.rotation);
                    gsap.to(activeLens.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.4, ease: "back.out(1.7)" });
                    activeLens.material.emissive.setHex(0x222222);
                    container.style.cursor = 'grabbing';
                } else {
                    activeLens = null;
                    container.style.cursor = 'move';
                }
            };

            const onMouseMove = (e) => {
                if (!isScattered) return;
                if (isDragging) {
                    const deltaX = e.clientX - prevMousePos.x;
                    const deltaY = e.clientY - prevMousePos.y;

                    if (activeLens) {
                        activeLens.rotation.z += deltaX * 0.015;
                        activeLens.rotation.x += deltaY * 0.015;
                    } else {
                        tiltGroup.rotation.y += deltaX * 0.005;
                        tiltGroup.rotation.x += deltaY * 0.005;
                        sceneRotationVelocityY = deltaX * 0.0001;
                        sceneRotationVelocityX = deltaY * 0.0001;
                    }
                    prevMousePos = { x: e.clientX, y: e.clientY };
                } else {
                    updateMouse(e);
                    raycaster.setFromCamera(mouse, lensCamera);
                    const intersects = raycaster.intersectObjects(lenses);
                    if (intersects.length > 0) {
                        container.style.cursor = 'grab';
                        const hoveredObj = intersects[0].object;
                        if (hoveredObj !== activeLens) {
                            gsap.to(hoveredObj.scale, { x: 1.1, y: 1.1, z: 1.1, duration: 0.3 });
                        }
                    } else {
                        container.style.cursor = 'default';
                        lenses.forEach(l => {
                            if (l !== activeLens) gsap.to(l.scale, { x: 1, y: 1, z: 1, duration: 0.3 });
                        });
                    }
                }
            };

            const onMouseUp = () => {
                if (activeLens) {
                    gsap.to(activeLens.scale, { x: 1, y: 1, z: 1, duration: 0.5, ease: "power2.out" });
                    activeLens.material.emissive.setHex(0x000000);
                }
                isDragging = false;
                activeLens = null;
                container.style.cursor = 'default';
            };

            container.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
            container.addEventListener('touchstart', (e) => onMouseDown(e.touches[0]));
            window.addEventListener('touchmove', (e) => onMouseMove(e.touches[0]));
            window.addEventListener('touchend', onMouseUp);

            const clock = new THREE.Clock();
            function animateLenses() {
                requestAnimationFrame(animateLenses);
                const time = clock.getElapsedTime();

                if (!isDragging || activeLens) {
                    if (isScattered) {
                        tiltGroup.rotation.y += sceneRotationVelocityY;
                        tiltGroup.rotation.x += sceneRotationVelocityX;
                        sceneRotationVelocityY *= 0.95;
                        sceneRotationVelocityX *= 0.95;
                    }
                }

                if (!isScattered) {
                    lensGroup.rotation.y -= 0.002;
                }

                lenses.forEach((lens, i) => {
                    if (lens !== activeLens) {
                        if (isScattered) {
                            const t = time * 0.5 + i;
                            lens.position.y += Math.sin(t) * 0.015;
                            lens.position.x += Math.cos(t * 0.8) * 0.03;
                            lens.rotation.z += 0.0005;
                            lens.rotation.x += 0.0005;

                            // 限制最大半径，让横向靠近边缘但不出屏
                            const maxR = 17.5;
                            const len = lens.position.length();
                            if (len > maxR) {
                                lens.position.multiplyScalar(maxR / len);
                            }
                        } else {
                            const t = time * 2 + i;
                            lens.position.y = lens.userData.basePos.y + Math.sin(t) * 0.1;
                        }
                    }
                });

                starField.rotation.y -= 0.0002;
                lensRenderer.render(scene, lensCamera);
            }
            animateLenses();

            const resizeLens = () => {
                const { w, h } = size();
                lensCamera.aspect = w / h;
                lensCamera.updateProjectionMatrix();
                lensRenderer.setSize(w, h);
            };
            window.addEventListener('resize', resizeLens);
        })();


        // --- 3. Scroll Animation (Intersection Observer) ---
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if(entry.isIntersecting){
                    const header = entry.target.querySelector('.section-header');
                    if (header) header.classList.add('visible');
                }
            });
        }, { threshold: 0.3 });

        document.querySelectorAll('section').forEach(sec => observer.observe(sec));


        // --- 4. 3D Tilt Effect for Persona Cards ---
        const cards = document.querySelectorAll('.tilt-card');
        document.addEventListener('mousemove', (e) => {
            const x = (window.innerWidth / 2 - e.pageX) / 90; // Reduced sensitivity
            const y = (window.innerHeight / 2 - e.pageY) / 90;
            cards.forEach(card => {
                card.style.transform = `perspective(1000px) rotateY(${x}deg) rotateX(${y}deg)`;
            });
        });


        // --- 5. Advice Reveal ---
        document.querySelectorAll('.advice-item').forEach(item => {
            item.addEventListener('click', () => {
                item.classList.toggle('active');
            });
        });


        // --- 6. Horizontal Scroll ---
        const scrollContainer = document.getElementById("scrollContainer");
        scrollContainer.addEventListener("wheel", (evt) => {
            // 将垂直滚轮转为时间轴横向滚动，避免页面纵向滚动冲突
            if (Math.abs(evt.deltaY) > Math.abs(evt.deltaX)) {
                evt.preventDefault();
                scrollContainer.scrollLeft += evt.deltaY;
            }
        }, { passive: false });

        // --- 7. Love Languages 3D (within Interaction) ---
        (() => {
            const container = document.getElementById('love-float-canvas');
            if (!container || !window.THREE) return;

            const loveWords = [
                "我爱你", "I Love You", "Je t'aime", "愛してる", "사랑해",
                "Ich liebe dich", "Te amo", "Ti amo", "Я тебя люблю", "Eu te amo",
                "Saranghae", "Aishiteru"
            ];

            const scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x020305, 8, 35); // 与全局粒子背景融合

            const camera = new THREE.PerspectiveCamera(
                65,
                Math.max(container.clientWidth, 1) / Math.max(container.clientHeight, 1),
                0.1,
                1000
            );
            camera.position.z = 6;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const particles = [];
            const particleCount = 80;

            function createTextSprite(text) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const fontSize = 56;
                ctx.font = `bold ${fontSize}px "Playfair Display", "Noto Serif SC", serif`;
                const metrics = ctx.measureText(text);
                const width = Math.max(metrics.width + 80, 260);
                const height = fontSize * 1.7;
                canvas.width = width;
                canvas.height = height;
                ctx.font = `bold ${fontSize}px "Playfair Display", "Noto Serif SC", serif`;
                ctx.fillStyle = 'rgba(255,255,255,1)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = "rgba(255, 182, 193, 0.75)";
                ctx.shadowBlur = 16;
                ctx.fillText(text, width / 2, height / 2);
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: 0.85,
                    color: 0xffffff
                });
                const sprite = new THREE.Sprite(material);
                const scale = 0.022;
                sprite.scale.set(width * scale, height * scale, 1);
                return sprite;
            }

            function resetParticle(sprite, initial = false) {
                sprite.position.x = (Math.random() - 0.5) * 30;
                sprite.position.y = (Math.random() - 0.5) * 20;
                sprite.position.z = initial ? (Math.random() * -40) : -40;
                sprite.material.rotation = (Math.random() - 0.5) * 0.25;
                const scaleVar = 0.8 + Math.random() * 0.5;
                sprite.scale.multiplyScalar(scaleVar);
            }

            for (let i = 0; i < particleCount; i++) {
                const word = loveWords[Math.floor(Math.random() * loveWords.length)];
                const sprite = createTextSprite(word);
                resetParticle(sprite, true);
                scene.add(sprite);
                particles.push(sprite);
            }

            let speed = 0.05;
            let targetSpeed = 0.05;
            let resetTimer;
            const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

            function animateLove() {
                requestAnimationFrame(animateLove);
                speed += (targetSpeed - speed) * 0.05;
                particles.forEach(p => {
                    p.position.z += speed;
                    if (p.position.z > camera.position.z) {
                        resetParticle(p);
                    }
                });
                renderer.render(scene, camera);
            }
            animateLove();

            // 左滑加速，右滑减速（触摸/鼠标拖动均可）
            let pointerDown = false;
            let startX = 0;
            const adjustSpeed = (deltaX) => {
                // deltaX < 0 表示左滑，加速；>0 右滑，减速
                targetSpeed = clamp(targetSpeed - deltaX * 0.0012, 0.05, 0.9);
                clearTimeout(resetTimer);
                resetTimer = setTimeout(() => { targetSpeed = 0.05; }, 800);
            };

            container.addEventListener('pointerdown', (e) => {
                pointerDown = true;
                startX = e.clientX;
            });
            window.addEventListener('pointerup', () => { pointerDown = false; });
            window.addEventListener('pointermove', (e) => {
                if (!pointerDown) return;
                const dx = e.clientX - startX;
                if (Math.abs(dx) > 6) {
                    adjustSpeed(dx);
                    startX = e.clientX;
                }
            });
            // 鼠标横向滚动也可微调
            container.addEventListener('wheel', (e) => {
                if (Math.abs(e.deltaX) < Math.abs(e.deltaY)) return;
                adjustSpeed(e.deltaX);
            }, { passive: true });

            const resize = () => {
                const w = Math.max(container.clientWidth, 1);
                const h = Math.max(container.clientHeight, 1);
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            };
            window.addEventListener('resize', resize);
            if (window.ResizeObserver) {
                const ro = new ResizeObserver(resize);
                ro.observe(container);
            } else {
                window.addEventListener('resize', resize);
            }
        })();

        // --- 8. BGM Control ---
        const bgm = document.getElementById('bgm');
        const musicToggle = document.getElementById('music-toggle');

        const updateMusicUI = () => {
            if (!musicToggle || !bgm) return;
            musicToggle.textContent = bgm.paused ? '▶︎' : '❚❚';
            musicToggle.setAttribute('aria-pressed', bgm.paused ? 'false' : 'true');
        };

        const tryPlayOnce = () => {
            if (!bgm) return;
            bgm.muted = false;
            bgm.play().catch(() => {});
            updateMusicUI();
        };

        window.addEventListener('pointerdown', tryPlayOnce, { once: true });
        window.addEventListener('touchstart', tryPlayOnce, { once: true });

        musicToggle?.addEventListener('click', () => {
            if (bgm.paused) bgm.play(); else bgm.pause();
            updateMusicUI();
        });

        updateMusicUI();

    </script>
</body>
</html>