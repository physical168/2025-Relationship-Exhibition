<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ˜Ÿæ²³é€é•œ | çˆ±çš„ç¿»è¯‘å™¨</title>
    
    <!-- å¼•å…¥ GSAP (ç”¨äºåŠ¨ç”») -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <!-- å¼•å…¥å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <!-- å¼•å…¥ç­‰å®½å­—ä½“ç”¨äºè¡¨å±‚è¯­è¨€ -->
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&display=swap" rel="stylesheet">
    
    <style>
        body { 
            margin: 0; 
            background: #020205; 
            color: #fff; 
            font-family: 'Noto Serif SC', serif; 
            overflow: hidden; 
            user-select: none; /* é˜²æ­¢æ‹–æ‹½æ—¶é€‰ä¸­æ–‡å­— */
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }
        
        #canvas-container:active {
            cursor: grabbing;
        }

        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 60px;
            z-index: 10;
            transition: opacity 0.5s;
        }

        h2 {
            font-size: 2.5rem;
            letter-spacing: 5px;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
            margin: 0 0 15px 0;
            background: linear-gradient(to bottom, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0.9;
        }

        .hint {
            font-size: 0.9rem;
            color: rgba(255,255,255,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 10px 25px;
            border-radius: 50px;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            animation: pulse 3s infinite ease-in-out;
            letter-spacing: 1px;
        }

        .loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 0.8rem;
            letter-spacing: 2px;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 20;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }
    </style>
</head>
<body>

    <div id="loading" class="loading">æ­£åœ¨è¿æ¥æ˜ŸåŸŸ...</div>
    <div id="canvas-container"></div>
    
    <div class="ui-layer" id="ui-layer">
        <h2>GALAXY LENSES</h2>
        <div class="hint">ğŸ–±ï¸ å‘ä¸‹æ»šåŠ¨æ•£å¼€ Â· æ‹–æ‹½é€é•œç¿»è½¬ Â· æ‹–æ‹½èƒŒæ™¯æ—‹è½¬</div>
    </div>

    <!-- ä½¿ç”¨ module ç±»å‹ï¼Œç›´æ¥ä» CDN å¯¼å…¥ Three.js -->
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';

        // 1. æ•°æ®å‡†å¤‡ (åŒ…å«æ‰€æœ‰15æ¡å†…å®¹)
        const cardsData = [
            { title: "å¤§æ€çš„è¯­è¨€", front: "å¿«å»ç”³è¯·å­¦æ ¡ï¼Œæ€ä¹ˆè¿˜æ²¡åšè¿™ä¸ªï¼Ÿ", back: "æˆ‘æƒ³å’Œä½ æœ‰ä¸€ä¸ªç¡®å®šçš„æœªæ¥ï¼Œæˆ‘æƒ³å’Œä½ ä¸€èµ·å˜å¾—æ›´å¥½ã€‚" },
            { title: "å‘¨æµ©çš„è¯­è¨€", front: "ç¡ä¸€è§‰å°±å¥½äº†ï¼Œæ²¡äº‹çš„ã€‚", back: "æˆ‘ä¸æƒ³è®©ä½ è¿™ä¹ˆç´¯ï¼Œæ— è®ºå‘ç”Ÿä»€ä¹ˆï¼Œæˆ‘éƒ½åœ¨è¿™é‡Œé™ªç€ä½ ã€‚" },
            { title: "æˆ‘ä»¬çš„æ¨¡å¼", front: "é£ç­ & çº¿", back: "å¤§æ€å¸¦ç€å‘¨æµ©çœ‹åˆ°æ›´å¹¿é˜”çš„ä¸–ç•Œï¼Œå‘¨æµ©ç»™å¤§æ€ç–²æƒ«æ—¶åœé çš„æ¸¯æ¹¾ã€‚" },
            { title: "å…³äºâ€œåƒâ€", front: "é¥¿æ­»æˆ‘äº† / åƒä¸ªé¥­å» / ç»™ä½ å¸¦äº†å‘€ç±³å‘€ç±³", back: "ä½ æ˜¯æˆ‘çš„ç”Ÿæ´»å¿…éœ€å“ã€‚æˆ‘æƒ³è§ä½ ï¼Œå“ªæ€•åªæ˜¯ååœ¨ä¸€èµ·åƒé¡¿æ— èŠçš„é¥­ã€‚" },
            { title: "å‘¨æµ©çš„â€œéšä¾¿â€", front: "éƒ½è¡Œ / å¬ä½ çš„ / éšä¾¿ / æ²¡æ„è§", back: "å› ä¸ºæ˜¯ä½ ï¼Œæ‰€ä»¥æˆ‘éƒ½å–œæ¬¢ã€‚æˆ‘ä¿¡ä»»ä½ çš„å“å‘³ï¼Œä¹Ÿäº«å—è¢«ä½ å®‰æ’çš„å®‰ç¨³æ„Ÿã€‚" },
            { title: "å¤§æ€çš„â€œåˆ†äº«â€", front: "[å›¾ç‰‡] (è·¯è¾¹çš„ç‹—) / [å›¾ç‰‡] (å¥‡æ€ªçš„äº‘)", back: "æˆ‘çš„ä¸–ç•Œå¦‚æœç¼ºå°‘äº†ä½ çš„æ³¨è§†ï¼Œå°±å˜å¾—é»¯æ·¡æ— å…‰ã€‚æˆ‘æƒ³è®©ä½ å‚ä¸æˆ‘ç”Ÿå‘½çš„æ¯ä¸€åˆ†é’Ÿã€‚" },
            { title: "äº‰åµæ—¶çš„â€œæ™šå®‰â€", front: "ç¡è§‰å§ / å›°äº† / æ™šå®‰ (åœ¨æ°”æ°›ä¸å¯¹æ—¶)", back: "æˆ‘ä¸æƒ³åµæ¶ä¼¤æ„Ÿæƒ…ã€‚æˆ‘ä»¬æš‚åœä¸€ä¸‹ï¼Œä½†è¯·æ”¾å¿ƒï¼Œæ˜å¤©é†’æ¥æˆ‘ä¾ç„¶çˆ±ä½ ã€‚" },
            { title: "å‘¨æµ©çš„â€œåœ¨æ¥¼ä¸‹â€", front: "ä¸‹æ¥ / åˆ°æ¥¼ä¸‹äº† / ç»™ä½ æ”¾é—¨å£äº†", back: "æˆ‘ä¸å–„è¨€è¾ï¼Œä½†æˆ‘æ°¸è¿œæ˜¯ä½ è§¦æ‰‹å¯åŠçš„ä¾é ã€‚ä½ éœ€è¦æˆ‘çš„æ—¶å€™ï¼Œæˆ‘ä¸€å®šåœ¨ã€‚" },
            { title: "å¤§æ€çš„â€œéª‚äººâ€", front: "ä½ æ˜¯çŒªå— / å‚»ç“œ / æ¬ æ", back: "è¿™æ˜¯æˆ‘å¯¹æœ€äº²å¯†çš„äººæ‰æœ‰çš„æ’’å¨‡ã€‚ä½ åœ¨æˆ‘é¢å‰å¯ä»¥ä¸ç”¨ä¼ªè£…æˆå¤§äººã€‚" },
            { title: "å‘¨æµ©çš„â€œå®šå¿ƒä¸¸â€", front: "å°é—®é¢˜ / æ²¡äº‹ / ä¸æ€¥ / æ…¢æ…¢æ¥", back: "åˆ«æ…Œï¼Œå¤©å¡Œä¸‹æ¥æœ‰æˆ‘é¡¶ç€ã€‚æ— è®ºé‡åˆ°ä»€ä¹ˆéº»çƒ¦ï¼Œæˆ‘éƒ½ä¼šé™ªä½ ä¸€èµ·è§£å†³ï¼Œåšä½ æœ€ç¨³çš„åç›¾ã€‚" },
            { title: "å¤§æ€çš„â€œè“å›¾â€", front: "ä»¥åæˆ‘ä»¬å»... / ä»¥åå…»åªç‹—", back: "æˆ‘çš„æœªæ¥è§„åˆ’é‡Œï¼Œæ¯ä¸€å¸§éƒ½æœ‰ä½ çš„èº«å½±ã€‚ç­‰å¾…ä¸æ˜¯å› ä¸ºæ— å¥ˆï¼Œè€Œæ˜¯å› ä¸ºå¯¹æˆ‘ä»¬å…±åŒç”Ÿæ´»çš„ç¬ƒå®šã€‚" },
            { title: "æœ€é«˜çº§çš„â€œä¸å«Œå¼ƒâ€", front: "æ‹‰å±å»äº† / é—»å± / [ä¸‘ç…§]", back: "æˆ‘ä»¬åœ¨å½¼æ­¤é¢å‰ä¸éœ€è¦ä»»ä½•ä¼ªè£…ã€‚çˆ±å°±æ˜¯è§è¿‡ä½ æœ€çœŸå®ã€æœ€ç‹¼ç‹ˆçš„æ ·å­ï¼Œä¾ç„¶è§‰å¾—ä½ å¯çˆ±ã€‚" },
            { title: "è§’è‰²æ‰®æ¼”", front: "å…„å¼Ÿ / è€å¼Ÿ / å§ / ä¹‰çˆ¶", back: "æˆ‘ä»¬ä¸ä»…æ˜¯æƒ…ä¾£ï¼Œæ›´æ˜¯æ­»å…šå’Œæˆ˜å‹ã€‚è¿™ç§å¤šé‡ç¾ç»Šæ˜¯è°ä¹Ÿå‰ªä¸æ–­çš„ã€‚" },
            { title: "å¼‚åœ°çš„â€œé€šæ„Ÿâ€", front: "æˆ‘ä¹Ÿåœ¨åƒ / æ¢¦åˆ°ä½ äº† / [åŒæ—¶å‘æ¶ˆæ¯]", back: "è™½ç„¶èº«å¤„å¼‚åœ°ï¼Œä½†çµé­‚åœ¨åŒä¸€æ—¶åŒºã€‚æˆ‘åœ¨åŠªåŠ›ç”¨ç»†èŠ‚å¡«è¡¥ç‰©ç†è·ç¦»ã€‚" },
            { title: "å¼ºåˆ¶ä¼‘æ¯", front: "å¿«å»ç¡ / åˆ«å­¦äº† / æŒ‚äº†æ˜‚", back: "çœ‹ç€ä½ ç´¯æˆ‘ä¼šå¿ƒç–¼ã€‚æ¯”èµ·ä½ çš„å‰é€”ï¼Œæˆ‘æ›´åœ¨æ„ä½ çš„å¥åº·ã€‚" }
        ];

        // 2. åœºæ™¯åˆå§‹åŒ–
        const container = document.getElementById('canvas-container');
        const loading = document.getElementById('loading');
        
        const scene = new THREE.Scene();
        // é»‘è‰²é›¾æ°”å¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x020205, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        // r128 è®¾ç½®
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild(renderer.domElement);

        // 3. ç¯å…‰ç³»ç»Ÿ
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // ç¨å¾®æäº®ç¯å¢ƒå…‰
        scene.add(ambientLight);

        // æš–è‰²ä¸»å…‰ (çœŸå¿ƒè¯é¢)
        const pointLight1 = new THREE.PointLight(0xffd700, 2.5, 100);
        pointLight1.position.set(15, 15, 20);
        scene.add(pointLight1);

        // å†·è‰²èƒŒå…‰ (è¡¨å±‚é¢)
        const pointLight2 = new THREE.PointLight(0xaaccff, 2.5, 100);
        pointLight2.position.set(-15, -15, 20);
        scene.add(pointLight2);
        
        // è¾¹ç¼˜è½®å»“å…‰
        const rectLight = new THREE.RectAreaLight(0xffffff, 5, 20, 20);
        rectLight.position.set(0, 20, 0);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        // 4. èƒŒæ™¯ç²’å­æ˜Ÿç©º
        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 4000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i=0; i<starsCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 300;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 0.15, color: 0xffffff, transparent: true, opacity: 0.6 });
        const starField = new THREE.Points(starsGeo, starsMat);
        scene.add(starField);

        // 5. æ ¸å¿ƒï¼šåˆ›å»ºé€é•œ
        const lenses = [];
        
        // æ–°å¢ï¼šå€¾æ–œçš„è½¨é“å®¹å™¨ (Orbit Group)
        const tiltGroup = new THREE.Group();
        scene.add(tiltGroup);
        
        const lensGroup = new THREE.Group();
        tiltGroup.add(lensGroup); // å°†æ—‹è½¬çš„é€é•œç»„æ”¾å…¥å€¾æ–œå®¹å™¨ä¸­

        // è®¾ç½®åˆå§‹å€¾æ–œçŠ¶æ€ï¼šå¯¹è§’çº¿å«æ˜Ÿè½¨é“ (Bottom-Left to Top-Right)
        // Zè½´æ—‹è½¬ 45åº¦ (æ§åˆ¶å¯¹è§’çº¿æ–¹å‘)
        // Xè½´æ—‹è½¬ 70åº¦ (æ§åˆ¶è½¨é“çš„æ‰å¹³ç¨‹åº¦ï¼Œçœ‹èµ·æ¥æ›´åƒä¸€ä¸ªå…‰ç¯)
        tiltGroup.rotation.z = Math.PI / 4; 
        tiltGroup.rotation.x = Math.PI / 2.5; 

        // çº¹ç†ç”Ÿæˆå‡½æ•°
        function createTextTexture(text, title, isBack = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // ç»˜åˆ¶åœ†å½¢èƒŒæ™¯ (ç»ç’ƒè´¨æ„Ÿæ¨¡æ‹Ÿ)
            ctx.beginPath();
            ctx.arc(256, 256, 240, 0, Math.PI * 2);
            // èƒŒé¢ç¨å¾®æ·±ä¸€ç‚¹ï¼Œå¢åŠ å¯¹æ¯”åº¦
            ctx.fillStyle = isBack ? 'rgba(10, 5, 20, 0.9)' : 'rgba(255, 255, 255, 0.08)';
            ctx.fill();
            
            // å†…å‘å…‰/è¾¹ç¼˜
            const grad = ctx.createRadialGradient(256, 256, 200, 256, 256, 240);
            grad.addColorStop(0, 'rgba(255,255,255,0)');
            grad.addColorStop(1, isBack ? 'rgba(255,215,0,0.3)' : 'rgba(255,255,255,0.2)');
            ctx.fillStyle = grad;
            ctx.fill();

            // è¾¹æ¡†
            ctx.lineWidth = 8;
            ctx.strokeStyle = isBack ? '#ffd700' : 'rgba(200,200,255,0.4)';
            ctx.stroke();

            // æ ‡é¢˜
            ctx.font = 'bold 32px "Noto Serif SC", serif';
            ctx.fillStyle = isBack ? '#ffd700' : 'rgba(255,255,255,0.8)';
            ctx.textAlign = 'center';
            ctx.fillText(title, 256, 100);
            
            // åˆ†å‰²çº¿
            ctx.beginPath();
            ctx.moveTo(156, 120);
            ctx.lineTo(356, 120);
            ctx.lineWidth = 2;
            ctx.strokeStyle = isBack ? 'rgba(255,215,0,0.5)' : 'rgba(255,255,255,0.3)';
            ctx.stroke();

            // æ­£æ–‡ (è‡ªåŠ¨æ¢è¡Œ)
            ctx.font = isBack ? '34px "Noto Serif SC", serif' : '32px "Courier Prime", monospace';
            ctx.fillStyle = isBack ? '#fff' : 'rgba(255,255,255,0.95)';
            
            let line = '';
            let y = 180;
            const lineHeight = 45;
            const maxWidth = 380;

            for(let n = 0; n < text.length; n++) {
                const testLine = line + text[n];
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    ctx.fillText(line, 256, y);
                    line = text[n];
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 256, y);

            const texture = new THREE.CanvasTexture(canvas);
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return texture;
        }

        // é€é•œå‡ ä½•ä½“
        const lensGeo = new THREE.CylinderGeometry(2.5, 2.5, 0.15, 64);
        
        // å‡çº§åçš„ç»ç’ƒæè´¨ (Crystal Glass)
        const glassMat = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.05,       
            roughness: 0.02,       
            transmission: 0.98,    
            thickness: 2.5,        
            envMapIntensity: 1.5,  
            clearcoat: 1.0,        
            clearcoatRoughness: 0.0,
            ior: 1.7,              
            side: THREE.DoubleSide
        });

        // æ–æ³¢é‚£å¥‘çƒç®—æ³•ï¼šç”Ÿæˆå‡åŒ€çš„çƒé¢åˆ†å¸ƒç‚¹ (æ•£å¼€åçš„ä½ç½®)
        function getFibonacciSpherePoints(samples, radius, randomize) {
            const points = [];
            const phi = Math.PI * (3.0 - Math.sqrt(5.0)); // é»„é‡‘è§’

            for (let i = 0; i < samples; i++) {
                const y = 1 - (i / (samples - 1)) * 2; // y ä» 1 åˆ° -1
                const radiusAtY = Math.sqrt(1 - y * y); // å½“å‰yåˆ‡é¢çš„åŠå¾„
                const theta = phi * i; // é»„é‡‘è§’å¢é‡

                const x = Math.cos(theta) * radiusAtY;
                const z = Math.sin(theta) * radiusAtY;

                points.push(new THREE.Vector3(x * radius, y * radius, z * radius));
            }
            return points;
        }

        const targetPoints = getFibonacciSpherePoints(cardsData.length, 12, true);

        cardsData.forEach((data, i) => {
            const lens = new THREE.Mesh(lensGeo, glassMat.clone());
            
            // Front
            const frontTex = createTextTexture(data.front, data.title, false);
            const planeGeo = new THREE.PlaneGeometry(3.6, 3.6);
            const frontMesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: frontTex, transparent: true, side: THREE.FrontSide }));
            frontMesh.rotation.x = -Math.PI / 2;
            frontMesh.position.y = 0.081; // å¾®è°ƒä½ç½®é¿å… z-fighting
            frontMesh.scale.set(0.85, 0.85, 0.85);
            lens.add(frontMesh);

            // Back
            const backTex = createTextTexture(data.back, "çœŸå¿ƒè¯", true);
            const backMesh = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: backTex, transparent: true, side: THREE.FrontSide }));
            backMesh.rotation.x = Math.PI / 2;
            backMesh.rotation.z = Math.PI;
            backMesh.position.y = -0.081;
            backMesh.scale.set(0.85, 0.85, 0.85);
            lens.add(backMesh);

            // åˆå§‹ä½ç½®ï¼šåœ†å½¢è½¨é“åˆ†å¸ƒ (Satellite Orbit Ring)
            const ringRadius = 12; // è½¨é“åŠå¾„åŠ å¤§
            const angleStep = (Math.PI * 2) / cardsData.length;
            const currentAngle = i * angleStep;
            
            // åœ¨ X-Z å¹³é¢ä¸Šåˆ†å¸ƒ
            const initX = Math.cos(currentAngle) * ringRadius;
            const initY = 0; 
            const initZ = Math.sin(currentAngle) * ringRadius;
            
            lens.position.set(initX, initY, initZ);
            
            // åˆå§‹æ—‹è½¬ï¼š
            // è®©é€é•œçœ‹èµ·æ¥åƒå›´ç»•ä¸­å¿ƒæ—‹è½¬çš„å«æ˜Ÿæ¿
            // æœ¬åœ°æ—‹è½¬ï¼šè®©åœ†æŸ±ä½“å¹³èºº -> é¢å‘åœ†å¿ƒ -> ç¨å¾®æŠ¬å¤´
            
            // 1. è®©åœ†æŸ±ä½“â€œç«™ç«‹â€å˜æˆâ€œå¹³èººâ€ (X -90åº¦)
            // 2. ç»•Yè½´æ—‹è½¬ä»¥é¢å‘ä¸­å¿ƒ (-currentAngle)
            // 3. ç¨å¾®è°ƒæ•´è§’åº¦ä»¥ä¾¿äºè§‚å¯Ÿ
            
            // æ³¨æ„ï¼šå› ä¸ºCylinderGeometryé»˜è®¤æ˜¯Yè½´æœä¸Šçš„ã€‚
            // æˆ‘ä»¬éœ€è¦å®ƒçœ‹èµ·æ¥åƒä¸ªç›˜å­ã€‚
            
            lens.rotation.set(0, -currentAngle, 0); // é¢å‘ä¸­å¿ƒ
            lens.rotateX(Math.PI / 2); // èººå¹³ï¼Œå˜æˆç›˜å­çŠ¶
            lens.rotateX(-Math.PI / 6); // ç¨å¾®æŠ¬å¤´ï¼Œæ­£é¢å¯¹ç€æ‘„åƒæœºè§†è§’

            // ç›®æ ‡ä½ç½®ï¼šå‡åŒ€åˆ†å¸ƒ
            const targetPos = targetPoints[i];
            const targetRot = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0);

            lens.userData = {
                id: i,
                targetPos: targetPos,
                targetRot: targetRot,
                basePos: lens.position.clone(), // åˆå§‹æ¼‚æµ®åŸºäºåœ†ç¯ä½ç½®
                velocity: new THREE.Vector3(), 
                floatPhase: Math.random() * Math.PI * 2
            };

            lensGroup.add(lens);
            lenses.push(lens);
        });
        
        loading.style.opacity = 0;

        // 6. äº¤äº’é€»è¾‘ (Raycaster)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // çŠ¶æ€æœº
        let isScattered = false;
        let activeLens = null; // å½“å‰æ‹–æ‹½çš„é•œç‰‡
        let isDragging = false;
        let prevMousePos = { x: 0, y: 0 };
        
        // æƒ¯æ€§æ—‹è½¬ç›¸å…³å˜é‡ (Scene)
        let sceneRotationVelocityX = 0;
        let sceneRotationVelocityY = 0;

        // æ»šåŠ¨äº¤äº’ (è§¦å‘æ•£å¼€)
        window.addEventListener('wheel', (e) => {
            if (!isScattered && e.deltaY > 0) {
                scatterLenses();
                isScattered = true;
                document.querySelector('.ui-layer').style.opacity = 0;
                setTimeout(() => document.querySelector('.ui-layer').style.pointerEvents = 'none', 500);
            }
        });
        
        window.addEventListener('touchmove', () => {
                if (!isScattered) {
                scatterLenses();
                isScattered = true;
                document.querySelector('.ui-layer').style.opacity = 0;
            }
        });

        // é¼ æ ‡äº‹ä»¶
        container.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        container.addEventListener('touchstart', (e) => onMouseDown(e.touches[0]));
        window.addEventListener('touchmove', (e) => onMouseMove(e.touches[0]));
        window.addEventListener('touchend', onMouseUp);

        function updateMouse(e) {
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(e) {
            if (!isScattered) return;

            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(lenses);

            isDragging = true;
            prevMousePos = { x: e.clientX, y: e.clientY };

            if (intersects.length > 0) {
                activeLens = intersects[0].object;
                gsap.killTweensOf(activeLens.rotation);
                
                // é«˜äº®ï¼šæ”¾å¤§ + å‘å…‰
                gsap.to(activeLens.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 0.4, ease: "back.out(1.7)" });
                activeLens.material.emissive.setHex(0x222222); 
                
                container.style.cursor = 'grabbing';
            } else {
                activeLens = null;
                container.style.cursor = 'move';
            }
        }

        function onMouseMove(e) {
            if (!isScattered) return;

            if (isDragging) {
                const deltaX = e.clientX - prevMousePos.x;
                const deltaY = e.clientY - prevMousePos.y;

                if (activeLens) {
                    activeLens.rotation.z += deltaX * 0.015;
                    activeLens.rotation.x += deltaY * 0.015;
                } else {
                    // æ—‹è½¬çš„æ˜¯ tiltGroup (æ•´ä¸ªå€¾æ–œè½¨é“)
                    tiltGroup.rotation.y += deltaX * 0.005;
                    tiltGroup.rotation.x += deltaY * 0.005;
                    sceneRotationVelocityY = deltaX * 0.0001;
                    sceneRotationVelocityX = deltaY * 0.0001;
                }
                
                prevMousePos = { x: e.clientX, y: e.clientY };
            } else {
                updateMouse(e);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(lenses);
                
                if (intersects.length > 0) {
                    container.style.cursor = 'grab';
                    const hoveredObj = intersects[0].object;
                    if (hoveredObj !== activeLens) {
                            gsap.to(hoveredObj.scale, {x:1.1, y:1.1, z:1.1, duration: 0.3});
                    }
                } else {
                    container.style.cursor = 'default';
                    lenses.forEach(l => {
                        if(l !== activeLens) gsap.to(l.scale, {x:1, y:1, z:1, duration: 0.3});
                    });
                }
            }
        }

        function onMouseUp() {
            if (activeLens) {
                gsap.to(activeLens.scale, { x: 1, y: 1, z: 1, duration: 0.5, ease: "power2.out" });
                activeLens.material.emissive.setHex(0x000000); // æ¢å¤ä¸å‘å…‰
            }
            isDragging = false;
            activeLens = null;
            container.style.cursor = 'default';
        }

        function scatterLenses() {
            // å¤åŸ tiltGroup çš„æ—‹è½¬ï¼Œè®©æ•£å°„çœ‹èµ·æ¥æ˜¯å‘å››é¢å…«æ–¹
            gsap.to(tiltGroup.rotation, { x: 0, z: 0, duration: 3, ease: "power2.inOut" });
            
            lenses.forEach((lens, index) => {
                gsap.to(lens.position, {
                    x: lens.userData.targetPos.x,
                    y: lens.userData.targetPos.y,
                    z: lens.userData.targetPos.z,
                    duration: 2.5,
                    ease: "power3.out", 
                    delay: index * 0.05 
                });
                gsap.to(lens.rotation, {
                    x: lens.userData.targetRot.x,
                    y: lens.userData.targetRot.y,
                    z: lens.userData.targetRot.z,
                    duration: 3,
                    ease: "power2.out"
                });
            });
            gsap.to(camera.position, { z: 40, duration: 3, ease: "power2.inOut" });
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (!isDragging || activeLens) {
                if (isScattered) {
                    tiltGroup.rotation.y += sceneRotationVelocityY;
                    tiltGroup.rotation.x += sceneRotationVelocityX;
                    sceneRotationVelocityY *= 0.95;
                    sceneRotationVelocityX *= 0.95;
                }
            }

            if (!isScattered) {
                // è½¨é“è‡ªè½¬ (å…¬è½¬)
                lensGroup.rotation.y -= 0.002; 
            }

            lenses.forEach((lens, i) => {
                if (lens !== activeLens) {
                    if (isScattered) {
                        const t = time * 0.5 + i;
                        const floatY = Math.sin(t) * 0.02;
                        const floatX = Math.cos(t * 0.8) * 0.02;
                        lens.position.y += floatY;
                        lens.position.x += floatX;
                        lens.rotation.z += 0.0005; 
                        lens.rotation.x += 0.0005;
                    } else {
                        // åœ¨è½¨é“ä¸Šå¾®åŠ¨ (ç›¸å¯¹äºæœ¬åœ°åæ ‡ç³»)
                        const t = time * 2 + i;
                        lens.position.y = lens.userData.basePos.y + Math.sin(t) * 0.1;
                    }
                }
            });

            starField.rotation.y -= 0.0002;
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>