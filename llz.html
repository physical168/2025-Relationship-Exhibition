<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>洛倫茲吸引子線條可視化</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 設置字體 -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #000; /* 黑色背景 */
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- UI 覆蓋層：僅顯示公式和名稱 -->
    <div id="info-display" class="fixed bottom-0 left-1/2 transform -translate-x-1/2 p-4 mb-2 text-center text-white bg-black bg-opacity-70 rounded-lg max-w-lg">
        <!-- 標題文字顏色更改為 text-cyan-300 以匹配線條顏色 -->
        <h1 id="pattern-name" class="text-xl font-bold mb-1 text-cyan-300">洛倫茲吸引子 (Lorenz Attractor)</h1>
        <!-- 使用 LaTeX 格式顯示公式 -->
        <p id="pattern-formula" class="text-sm font-mono italic">
            $$ \frac{dx}{dt} = \sigma(y-x), \quad \frac{dy}{dt} = x(\rho-z)-y, \quad \frac{dz}{dt} = xy-\beta z $$
        </p>
    </div>

    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script type="module">
        // 點的數量，減小到 5000 以降低密度
        const MAX_POINTS = 5000; 
        // 亮青色/水綠色 (0x33FFFF)
        const BRIGHT_GREEN = 0x33FFFF; 

        let scene, camera, renderer, controls, clock;
        let line; 
        let lineColors; // 儲存顏色屬性陣列的引用，用於動畫

        // 輔助向量和顏色，避免在循環中重複創建對象
        const tempVector1 = new THREE.Vector3();
        const tempVector2 = new THREE.Vector3();
        const tempColor = new THREE.Color();
        const baseColor = new THREE.Color(BRIGHT_GREEN);


        // 初始化 Three.js 場景
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // 黑色背景

            // 設置相機 (視野, 寬高比, 近平面, 遠平面)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(40, 0, 0); // 初始位置調整到較遠處

            // 渲染器設置
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // 軌道控制器，用於用戶交互
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // 啟用阻尼效果（更平滑）
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.target.set(0, 0, 0); // 聚焦於原點
            controls.update();

            clock = new THREE.Clock();

            // 加載洛倫茲吸引子線條
            loadLorenzAttractor();

            // 設置事件監聽器
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        // --- 洛倫茲吸引子生成函數 ---
        function generateLorenzAttractorGeometry() {
            // 經典參數
            const s = 10.0; // Sigma
            const r = 28.0; // Rho
            const b = 8.0 / 3.0; // Beta
            const dt = 0.005; // 步長
            
            let x = 0.1, y = 0, z = 0;
            const positions = []; 

            // 預熱迭代以穩定軌道 (防止初始階段混亂)
            const PRE_HEAT = 1000;
            for (let i = 0; i < PRE_HEAT; i++) {
                const dx = s * (y - x) * dt;
                const dy = (x * (r - z) - y) * dt;
                const dz = (x * y - b * z) * dt;
                x += dx;
                y += dy;
                z += dz;
            }

            // 生成軌道點
            for (let i = 0; i < MAX_POINTS; i++) {
                const dx = s * (y - x) * dt;
                const dy = (x * (r - z) - y) * dt;
                const dz = (x * y - b * z) * dt;
                x += dx;
                y += dy;
                z += dz;
                
                positions.push(x, y, z);
            }
            
            // --- 自動縮放和居中 ---
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            
            for (let i = 0; i < positions.length; i += 3) {
                minX = Math.min(minX, positions[i]);
                maxX = Math.max(maxX, positions[i]);
                minY = Math.min(minY, positions[i+1]);
                maxY = Math.max(maxY, positions[i+1]);
                minZ = Math.min(minZ, positions[i+2]);
                maxZ = Math.max(maxZ, positions[i+2]);
            }
            
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const rangeZ = maxZ - minZ;
            const maxRange = Math.max(rangeX, rangeY, rangeZ);
            
            // 縮放因子，將吸引子範圍縮放到約 30 個單位，使其適應相機視野
            const globalScale = 30 / maxRange; 
            const offsetX = (minX + maxX) / 2;
            const offsetY = (minY + maxY) / 2;
            const offsetZ = (minZ + maxZ) / 2;
            
            const finalPositions = new Float32Array(positions.length);
            for (let i = 0; i < positions.length; i += 3) {
                // 居中並縮放
                finalPositions[i] = (positions[i] - offsetX) * globalScale;
                finalPositions[i+1] = (positions[i+1] - offsetY) * globalScale;
                finalPositions[i+2] = (positions[i+2] - offsetZ) * globalScale;
            }
            
            // 創建顏色緩衝區，用於流光效果
            const colors = new Float32Array(finalPositions.length);
            
            for (let i = 0; i < finalPositions.length; i += 3) {
                // 初始設定為基礎顏色 (稍後在 animate 中計算角度依賴的顏色)
                colors[i] = baseColor.r;
                colors[i + 1] = baseColor.g;
                colors[i + 2] = baseColor.b;
            }


            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(finalPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); // 添加顏色屬性
            
            lineColors = geometry.attributes.color.array; // 存儲顏色陣列的引用
            return geometry;
        }

        // 加載洛倫茲吸引子
        function loadLorenzAttractor() {
            // 清除現有物體
            if (line) {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
            }

            // 1. 生成幾何體 (包含所有連點的座標和初始顏色)
            const geometry = generateLorenzAttractorGeometry();

            // 2. 創建材質 (LineBasicMaterial 實現單色線條和輝光)
            const material = new THREE.LineBasicMaterial({
                color: BRIGHT_GREEN, 
                vertexColors: true, // 啟用頂點顏色，以實現流光效果
                linewidth: 1, 
                blending: THREE.AdditiveBlending, // 啟用疊加混合，實現輝光/發光效果
                transparent: true,
                opacity: 0.9, // 略微提高不透明度以增強亮度
            });

            // 3. 創建 Line 系統 (將所有點連接成一條線)
            line = new THREE.Line(geometry, material);
            line.rotation.order = 'YXZ'; // 設置旋轉順序
            scene.add(line);
        }
        
        // 窗口尺寸變更時調整渲染器和相機
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 主渲染循環
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            
            // 順時針不斷位移流動：通過旋轉整個線條來實現
            const rotationSpeed = 0.05 * delta; // 旋轉速度
            if (line) {
                line.rotation.y += rotationSpeed; // 沿 Y 軸旋轉
            }
            
            // --- 流光溢彩效果與角度依賴亮度 ---
            if (line && lineColors) {
                const colorsAttribute = line.geometry.attributes.color;
                const positionAttribute = line.geometry.attributes.position;
                const positions = positionAttribute.array;
                const len = MAX_POINTS * 3;
                
                // 獲取當前相機位置（世界坐標）
                const cameraPosition = camera.position;
                
                // 時間因子，用於輕微的脈動/流動效果
                const time = clock.getElapsedTime() * 0.5; 
                const pulseFactor = (Math.sin(time) * 0.05) + 0.95; // 0.95 到 1.0 之間微小脈動

                for (let i = 0; i < len - 3; i += 3) {
                    // P1 和 P2 形成線段
                    tempVector1.set(positions[i], positions[i + 1], positions[i + 2]);
                    // 如果是最後一個點，則使用自身作為方向向量（或者直接跳過，這裡使用下一個點）
                    tempVector2.set(positions[i + 3], positions[i + 4], positions[i + 5]);

                    // 1. 計算線段方向 (Segment Direction / Tangent)
                    // 線段向量: P2 - P1
                    const segmentDirection = tempVector2.clone().sub(tempVector1).normalize();

                    // 2. 計算視角方向 (View Direction)
                    // 視角向量: P1 - Camera (從線段到相機)
                    const viewDirection = tempVector1.clone().sub(cameraPosition).normalize(); 

                    // 3. 角度調製: 側對/邊緣 (Edge-on) = 最亮
                    // 點積的絕對值: 0 (垂直/側對) 到 1 (平行/正對)
                    const dotProduct = Math.abs(segmentDirection.dot(viewDirection));
                    
                    // 邊緣亮度因子: 1 - dotProduct。這確保垂直於視角的線段最亮
                    let edgeFactor = 1.0 - dotProduct;
                    
                    // 提高指數以使亮度的衰減更尖銳 (模擬輝光效果)
                    edgeFactor = Math.pow(edgeFactor, 3); 

                    // 4. 計算最終亮度
                    const MIN_BRIGHTNESS = 0.1; // 確保線條不完全消失
                    const MAX_BRIGHTNESS_RANGE = 0.9;
                    
                    // 最終亮度 = 最小亮度 + (角度敏感度 * 亮度範圍 * 脈動)
                    const finalFactor = MIN_BRIGHTNESS + (edgeFactor * MAX_BRIGHTNESS_RANGE * pulseFactor);

                    // 5. 應用顏色
                    tempColor.copy(baseColor).multiplyScalar(finalFactor);

                    // 應用顏色到 P1
                    lineColors[i] = tempColor.r;
                    lineColors[i + 1] = tempColor.g;
                    lineColors[i + 2] = tempColor.b;
                    
                    // 應用顏色到 P2 (確保線段兩端顏色一致)
                    if (i + 3 < len) {
                         lineColors[i + 3] = tempColor.r;
                         lineColors[i + 4] = tempColor.g;
                         lineColors[i + 5] = tempColor.b;
                    }
                }

                colorsAttribute.needsUpdate = true; // 通知 Three.js 顏色緩衝區已更新
            }

            controls.update(); // 更新軌道控制器

            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>